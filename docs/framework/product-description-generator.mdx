---
title: "Product description generator"
---

# Writer Framework tutorial: Product Description Generator

In this tutorial, you will use Writer Framework to build a Saturn Snacks product description generator for a variety of food outlets. After adding the initial functionality of the app, you will also extend the app to include a chart of SEO keyword analysis and the ability for users to add their own food outlet.

[IMAGE: Gif of finished project with alt text]


## Setting up your project


### Creating a Writer app and getting your API key

From the Home screen, click on Build an app.

[IMAGE: Screenshot of home screen]

Select Framework as the app type you’d like to create, enabling you to generate keys and build your app with the Writer Framework.

[IMAGE: Screenshot of app type selection]

On the next screen, you can edit your Writer application name in the upper left. Underneath “Authenticate with an API key,” click on “Reveal” to see and copy your API key.


### Creating the application

Next, open your terminal and navigate to the directory where you want to create your application directory.

To pass your API key to Writer Framework, you will need to set an environment variable called `WRITER_API_KEY`. One simple way to do this is by exporting the variable for your terminal session. On Mac and Linux, you can run the following command, replacing `key` with your API key:


```
export WRITER_API_KEY=[key]
```


On Windows, use the following:


```
set WRITER_API_KEY=[key]
```


To create the application, run the following command:


```
writer create product-description-app --template=pdg-tutorial
```


This command will set up a new project called `product-description-app` in the specified directory using a template created for this tutorial. To edit your project, run this command: 


```
writer edit product-description-app
```


This will bring up the console, where Framework-wide messages and errors will appear, including logs from the API. 

By default, the Writer Framework builder is accessible at `localhost:3006`. If that port is in use, run the `edit` command again with the `port` flag to specify your desired port:


```
writer edit product-description-app –port=3007
```


Open this address in your browser to view your default application setup.


## Introduction to the Application Setup
When you first start up the application, you're going to see two main layout items provided by the template:



* A header component with the name of the application
* A column container that will house most of the UI of the app

The left column includes a form that has three text inputs and a button. These three text inputs are bound to corresponding state elements. The right column contains a message component for loading and status messages, as well as an empty tab container which you'll use to display the product descriptions of the various outlets.


### Code overview

Looking at the code in `main.py`, you'll see that the template already imported the Writer Framework, the AI module, and the product description prompts that you will use throughout this tutorial. 

```python
import writer as wf
import writer.ai
from prompts import base_prompts, user_prompt, seo_keywords
```

The prompts are stored in a separate file called `prompts.py`. You are welcome to open this project in the IDE of your choice and modify the prompts however you wish. However, you don't need to make any changes to this file to follow this tutorial. 

You'll also see the state initialization:

```python
wf.init_state({
   "form": {
       "title": "",
       "description": "",
       "keywords": ""
   },
   "message": "Fill in the inputs and click \"Generate\" to get started.",
})
```

The form elements and the message have been initialized as strings. You will add to this state dictionary throughout the tutorial. 


## Implementing the Product Description Generator

Your first goal is to generate product descriptions for the various food outlets, with each outlet appearing as a tab to the right of the form.

[IMAGE: Screenshot of finished descriptions]


### Setting up the code

First, paste the following method on line 5 after all of the imports:

```python
def _generate_product_description(base_prompt, product_info):
   prompt = base_prompt.format(**product_info)
   description = writer.ai.complete(prompt)
   return description
```

This helper function accepts a base prompt as well as the product information from the form on the page. Note that the product description helper has an underscore at the beginning of its name, indicating that it's a private method not exposed to the UI. 

Next, you’ll initialize some additional state elements and create a handler for the button on the form. 

First, update `wf.init_state()` to include the `product_description` dictionary:

```python
wf.init_state({
   "form": {
       "title": "",
       "description": "",
       "keywords": ""
   },
   "message": "Fill in the inputs and click \"Generate\" to get started.",
   "product_descriptions": {
       "visible": False,
       "outlets": {}
   }
})
```

This dictionary includes a variable called `visible` that will allow you to control whether the product description tabs are hidden or visible. It also includes an empty dictionary called `outlets` to which the button click handler will add.

To add the button click handler, paste the following method beneath `_generate_product_description`:

```python
def handle_click(state):
   state["product_descriptions"]["visible"] = False


   # Loop through all the base prompts to generate versions tailored to each outlet
   for outlet, base_prompt in base_prompts.items():
       state["message"] = f"% Generating product description for {outlet}..."
       product_description = _generate_product_description(base_prompt, state["form"].to_dict())
       state["product_descriptions"]["outlets"][outlet] = product_description


   state["product_descriptions"]["visible"] = True
   state["message"] = ""
```

This handler will loop through each imported base prompt, format it with the form information, and pass it to the helper method. It then adds the resulting product description to the `state["product_descriptions"]["outlets"]` dictionary. The click handler method also includes some UI touches, such as showing and hiding the product descriptions and adding and removing loading messages to the message component.


### Setting Up the User Interface

You can now set up the UI to iterate over the product descriptions dictionary and create tabs. To do this, open the User iInterface. In the toolkit, drag a Repeater component from the Other section into the empty Tab Container. 

Click on the Repeater component to open its component settings. Under Properties, add `@{product_descriptions.outlets}` as the Repeater object to be used for repeating the child components. Set “Key variable name” to `itemID` and “Value variable name” to `item`. 

[IMAGE: Screenshot of Repeater component settings]

Next, from the Layout section of the toolkit, drag a Tab component into the Repeater. Click on the Tab to bring up the component settings and add `@{itemID}` to the Name property. This will display the outlet name on the tab. 

[IMAGE: Screenshot of Tab component settings]

To display the resulting text from the call to the AI module, drag a Text component from the Content section of the Toolkit into the Tab. Click on the Text component to open the Component settings and set the Text property to `@{item}`. You may also choose to set “Use Markdown” to “yes.” 

[IMAGE: Screenshot of Text component settings]

To control the visibility of the Tab Container, click on the Tab Container to bring up its component settings. Scroll to the bottom and, under Visibility, click “Custom” and add `product_descriptions.visible` to the Visibility value input. 

[IMAGE: Screenshot of Tab Container visibility setting]

Lastly, to wire up the form, click on the Generate button inside the form to bring up its component settings. In the Events section, select `handle_click` for the `wf-click` event. 

[IMAGE: Screenshot of Button settings]

Now, click Preview in the top toolbar, enter some test data, and click the Generate button. You should see a loading message, as well as three example food outlets displayed in the tabs. The loading message should disappear when everything is loaded, and the tab should remain visible once the data has loaded.

Great work!


## Expanding the application: SEO keyword analysis

You can expand on this application by adding a chart that displays the top ten SEO keywords present in the product descriptions. 


### Updating the code

To do this, back in the code, first add the following helper function underneath your ` _generate_product_description` helper method: 

```python
def _generate_seo_keywords(outlets):
   combined_descriptions = "\n".join(f"{key}: {value}" for key, value in outlets.items())


   # Generate the prompt with the provided descriptions
   prompt = seo_keywords.format(descriptions=combined_descriptions)
   # Strip out whitespace and backticks from the response
   return writer.ai.complete(prompt).strip(" `\n")

```

This method concatenates all of the product descriptions and incorporates them into a prompt in `prompts.py`. It then sends the formatted prompt to the Palmyra LLM using the `complete` method. The prompt not only analyzes the descriptions for SEO keywords, but also outputs a [Plotly.js](Plotly.js) schema object that you can use directly with a Plotly graph component. 

With the helper method in place, you can now update the click handler for the button. On line 27, add the following code:

```python
# Create the SEO analysis
   state["message"] = "Analyzing SEO keywords..."
   outlets = state["product_descriptions"]["outlets"]
   state["seo_analysis"] = _generate_seo_keywords(outlets)
```

This code sets the loading message and passes all of the product descriptions to the SEO keyword helper method. 


### Adding SEO analysis to the UI

To update the UI to display this chart, first drag a new tab from the Layout section of the toolkit into the Tab Container. This tab should not be inside of the Repeater, but can be either before or after it. Click on the tab to open the component settings, and change the name to “SEO Analysis.” If you'd like, you can also set the Visibility to “Custom” and set `seo_analysis` as the visibility value. 

[IMAGE: Screenshot of new tab settings]

To display the chart, drag a Plotly Graph component from the Content section of the toolkit into your new Tab. Click on the component to bring up the component settings. The Plotly graph component accepts a graph specification. Add `seo_analysis` to pass the LLM-generated graph specification to the component. 

Click preview, add some data to the form, and click generate. You should see a new SEO analysis tab appear with a nicely formatted and labeled chart. 

[IMAGE: Screenshot of SEO analysis tab]


## Extending the application: user-added outlet 

Finally, you can extend this application even further by allowing users to add their own custom food outlet and derive a new description from a custom prompt. 


### Adding the new form

Start by building the UI for this new form. From the Layout section of the Toolkit, drag a new Section component into the column where the current form is and drop it above or below it. Click on the Section and change the Name to “Add an outlet.” 

To create the inputs for the form, drag a Text Input and a Number Input from the Input section of the Toolkit into the newly created section. Click on the Text Input component to change the Label to “Outlet name.” Click on the Number Input and change the label to “Character max.” 

Finally, add a Button from the Other section of the toolkit to the bottom of the new section. Click on the button and change the text to “Add and Generate.” You can also add `laps` or another [Material Symbols](https://fonts.google.com/icons) ID to the Icon input if you wish. 

[IMAGE: Screenshot of form]


### Updating the code

In the code, you next need to add corresponding state elements for the new form components to `wf.init_state()`. Add the following to the state dictionary: 

```python
"outlet_form": {
       "name": "",
       "character_max": "",
   },
```

Don't forget to check your commas when adding to the state dictionary. Your completed state should look like this:

```python
wf.init_state({
   "form": {
       "title": "",
       "description": "",
       "keywords": ""
   },
   "outlet_form": {
       "name": "",
       "character_max": "",
   },
   "message": "Fill in the inputs and click \"Generate\" to get started.",
   "product_descriptions": {
       "visible": False,
       "outlets": {}
   }
})
```

The `outlet_form` state elements will bind to the form elements. 

Next, add the click handler for the new button. Copy and paste this `handle_add_outlet` method into the code under the `handle_click` method:

```python
def handle_add_outlet(state):
   # Create a new base prompt for the new outlet
   new_outlet_name = state["outlet_form"]["name"]
   product_info = {**state["outlet_form"].to_dict(), **state["form"].to_dict()}
   base_prompt = user_prompt.format(**product_info)


   # Add the new base prompt to the base_prompts dictionary
   base_prompts[new_outlet_name] = base_prompt


   # Generate the product description for the new outlet
   state["message"] = f"% Generating product description for {new_outlet_name}..."
   product_description = _generate_product_description(base_prompt, state["form"].to_dict())
   state["product_descriptions"]["outlets"][new_outlet_name] = product_description


   # Update the SEO analysis
   state["message"] = "Updating SEO analysis..."
   outlets = state["product_descriptions"]["outlets"]
   state["seo_analysis"] = _generate_seo_keywords(outlets)


   state["message"] = ""
```

This method formats the input from both forms into the imported `user_prompt` and adds the formatted prompt to the `base_prompts` dictionary. It then generates the product description for the new food outlet, updates the SEO analysis, and clears the status message. 


### Binding the elements and handler to the UI

Finally, bind the state elements and the click handler to the UI. 

First, click on the “Outlet name” Text Input and, under Binding, set the state element to `outlet_form.name`. Click on the “Character max” Text Input and change the state element binding to `outlet_form.character_max`. Then, click on the “Add and Generate” Button and select `handle_add_outlet` to the `wf-click` event in the Events section of the component settings. 

Finally, if you'd like to hide this form until some of the descriptions have been generated, click on the Section for the form, and in the Visibility section, click “Custom” and add `product_descriptions.visible` as the “Visibility value.” 


### Testing the finished product

To see the result of your hard work, click Preview in the top toolbar, enter some information into the original product description form, and click “Generate.” The “Add an outlet” form should appear once the product descriptions have been generated. Add a new example outlet name and a character max and click “Add and Generate.” You should see a new tab appear with your new outlet, as well as an updated SEO analysis chart. 

[IMAGE: Gif of working application]

You can add whatever additional form inputs you wish to the outlet form, but be sure to update `user_prompt` in the `prompts.py` file using your favorite editor.


## Deploying the application

To deploy the application to the Writer cloud, either terminate your current Writer Framework process or open a new terminal session and run the following command:


```
writer deploy product-description-app
```


You’ll be prompted for your API key.

Once the application has been deployed, the CLI will return with the URL of your live application.


## Conclusion

You’ve now built a full application with Writer Framework and the Writer AI module. Congratulations! This setup not only demonstrates the platform's capabilities but also provides a foundation on which you can build more complex applications. To learn more, explore the rest of the Writer Framework documentation and the API documentation.